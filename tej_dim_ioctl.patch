diff --git a/CODE_OF_CONDUCT.rst b/CODE_OF_CONDUCT.rst
old mode 100644
new mode 100755
diff --git a/CONTRIBUTING.rst b/CONTRIBUTING.rst
old mode 100644
new mode 100755
diff --git a/DCO b/DCO
old mode 100644
new mode 100755
diff --git a/Documentation/manifest-syntax.rst b/Documentation/manifest-syntax.rst
index 50c26424..5712e9ca 100644
--- a/Documentation/manifest-syntax.rst
+++ b/Documentation/manifest-syntax.rst
@@ -757,6 +757,143 @@ they were listed as ``allowed_files``. (However, this policy still does not
 allow writing/creating files specified as trusted.) This policy is a convenient
 way to determine the set of files that the ported application uses.
 
+Allowed IOCTLs
+^^^^^^^^^^^^^^
+
+::
+
+    sgx.ioctl_structs.[identifier] = [memory-layout-format]
+
+    sgx.allowed_ioctls = [
+      { request_code = [NUM], struct = "[identifier-of-ioctl-struct]" },
+    ]
+
+By default, Gramine disables all device-backed IOCTLs. This syntax allows to
+explicitly allow a set of IOCTLs on devices (devices must be explicitly mounted
+via ``fs.mounts`` manifest syntax). Only IOCTLs with the ``request_code``
+argument found among the manifest-listed IOCTLs are allowed to pass-through to
+the host. Each IOCTL entry may also contain a reference to an IOCTL struct in
+the ``struct`` field, in case the third IOCTL argument is intended to be
+translated by Gramine.
+
+Available IOCTL structs are described via ``sgx.ioctl_structs``. Each IOCTL
+struct describes the memory layout of the third argument to the ``ioctl`` system
+call (typically a pointer to a complex nested object passed to the device).
+Description of the memory layout is required for a deep copy of the IOCTL
+struct. We use the term *memory region* to denote a separate contiguous region
+of memory and the term *sub-region of a memory region* to denote a part of the
+memory region that has properties different from other sub-regions in the same
+memory region (e.g., should it be copied in or out of the SGX enclave, is it a
+pointer to another memory region, etc.). For example, a C struct can be
+considered one memory region, and fields of this C struct can be considered
+sub-regions of this memory region.
+
+Memory layout of the IOCTL struct is described using the TOML syntax of inline
+arrays (for each new separate memory region) and inline tables (for each
+sub-region in one memory region). Each sub-region is described via the following
+keys:
+
+- ``name`` is an optional name for this sub-region; mainly used to find
+  length-specifying fields and nested memory regions.
+- ``align`` is an optional alignment of the memory region; may be specified only
+  in the first sub-region of a memory region (all other sub-regions are
+  contigious with the first sub-region, so specifying their alignment doesn't
+  make sense).
+- ``size`` is a mandatory size of this sub-region. The ``size`` field may be a
+  string with the name of another field that contains the size value or an
+  integer with the constant size measured in ``unit`` units (default unit is 1
+  byte; also see below). For example, ``size = "strlen"`` denotes a size field
+  that will be calculated dynamically during IOCTL execution based on the
+  sub-region named ``strlen``, whereas ``size = 16`` denotes a sub-region of
+  size 16B. Note that ``ptr`` sub-regions must *not* specify the ``size`` field.
+- ``unit`` is an optional unit of measurement for ``size``. It is 1 byte by
+  default. Unit of measurement must be a constant integer. For example,
+  ``size = "strlen"`` and ``unit = 2`` denote a wide-char string (where each
+  character is 2B long) of a dynamically specified length.
+- ``adjust`` is an optional integer adjustment for ``size`` (always specified in
+  bytes). It is 0 bytes by default. This field must be a constant (possibly
+  negative) integer. For example, ``size = 6``, ``unit = 2`` and ``adjust = -8``
+  results in a total size of 4B.
+- ``array_len`` denotes the number of items in the ``ptr`` array. This field
+  cannot be specified with non-``ptr`` regions.
+- ``direction = "none" | "out" | "in" | "inout"`` is an optional direction of
+  copy for this sub-region. For example, ``direction = "out"`` denotes a
+  sub-region to be copied out of the enclave to untrusted memory, i.e., this
+  sub-region is an input to the host device. The default value is ``none`` which
+  is useful for e.g. padding of structs. This field must be ommitted if the
+  ``ptr`` field is specified for this sub-region (pointer sub-regions contain
+  the pointer value which will be unconditionally rewired to point to untrusted
+  memory).
+- ``ptr = inlined-memory-region`` or ``ptr = "another-ioctl-struct"``
+  specifies a pointer to another, nested memory region. This field is required
+  when describing complex IOCTL structs. Such pointer memory region always has
+  the implicit size of 8B, and the pointer value is always rewired to the memory
+  region in untrusted memory (containing a corresponding nested memory region).
+  If ``ptr`` is specified together with ``array_len``, it describes an array of
+  these memory regions. (In other words, ``ptr`` is an array of memory regions
+  with ``array_len = 1`` by default.)
+
+Consider this simple C snippet::
+
+    struct ioctl_read {
+        size_t buf_size;  /* copied from enclave to device */
+        char* buf;        /* copied from device to enclave */
+    } aligned(0x1000);    /* alignment just for illustration */
+
+This translates into the following manifest syntax::
+
+    sgx.ioctl_structs.ioctl_read = [
+        {
+            name      = "buf_size",
+            size      = 8,
+            direction = "out",
+            aligned   = 0x1000
+        },
+        {
+            ptr = [
+                {
+                    size      = "buf_size",
+                    direction = "in"
+                }
+            ]
+        }
+    ]
+
+The above example specifies a root struct (first memory region) that consists of
+two sub-regions: the first one contains an 8-byte size value, the second one is
+an 8-byte pointer value. This pointer points to another memory region in enclave
+memory that contains a single sub-region of size ``buf_size``. This nested
+sub-region is copied from the device into the enclave.
+
+IOCTLs that use the above struct in a third argument are defined like this::
+
+    sgx.allowed_ioctls = [
+      { request_code = 0x12345678, struct = "ioctl_read" },
+      { request_code = 0x87654321, struct = "ioctl_read" },
+    ]
+
+If the IOCTL's third argument should be passed directly as-is (or unused at
+all), then the ``struct`` key must be an empty string or not exist at all::
+
+    sgx.allowed_ioctls = [
+      { request_code = 0x43218765, struct = "" },
+      { request_code = 0x87654321 },
+    ]
+
+.. note ::
+   IOCTLs for device communication are pass-through and thus insecure by
+   themselves in SGX environments:
+
+       - IOCTL arguments are passed as-is from the app to the untrusted host,
+         which may lead to leaks of enclave data.
+       - Untrusted host can change IOCTL arguments as it wishes when passing
+         them from Gramine to the device and back.
+
+   It is the responsibility of the app developer to correctly use IOCTLs, with
+   security implications in mind. In most cases, IOCTL arguments should be
+   encrypted or integrity-protected with a key pre-shared between Gramine and
+   the device.
+
 Attestation and quotes
 ^^^^^^^^^^^^^^^^^^^^^^
 
diff --git a/LICENSE.addendum.txt b/LICENSE.addendum.txt
old mode 100644
new mode 100755
diff --git a/LICENSE.txt b/LICENSE.txt
old mode 100644
new mode 100755
diff --git a/README.rst b/README.rst
old mode 100644
new mode 100755
diff --git a/libos/src/sys/libos_ioctl.c b/libos/src/sys/libos_ioctl.c
index 44aa446a..3cb8fdd2 100644
--- a/libos/src/sys/libos_ioctl.c
+++ b/libos/src/sys/libos_ioctl.c
@@ -13,6 +13,8 @@
 #include "libos_signal.h"
 #include "libos_table.h"
 #include "pal.h"
+#include "stat.h"
+#include <sys/ioctl.h>
 
 static void signal_io(IDTYPE caller, void* arg) {
     __UNUSED(caller);
@@ -30,6 +32,8 @@ static void signal_io(IDTYPE caller, void* arg) {
 }
 
 long libos_syscall_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg) {
+    int ret;
+
     struct libos_handle_map* handle_map = get_thread_handle_map(NULL);
     assert(handle_map);
 
@@ -37,7 +41,24 @@ long libos_syscall_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg) {
     if (!hdl)
         return -EBADF;
 
-    int ret;
+    lock(&g_dcache_lock);
+    bool is_host_dev = hdl->type == TYPE_CHROOT && hdl->dentry->inode &&
+        hdl->dentry->inode->type == S_IFCHR;
+    unlock(&g_dcache_lock);
+
+    if (is_host_dev) {
+        int cmd_ret;
+        ret = PalDeviceIoControl(hdl->pal_handle, cmd, arg, &cmd_ret);
+        if (ret < 0) {
+            ret = pal_to_unix_errno(ret);
+            goto out;
+        }
+
+        assert(ret == 0);
+        ret = cmd_ret;
+        goto out;
+    }
+
     switch (cmd) {
         case TIOCGPGRP:
             if (!hdl->uri || strcmp(hdl->uri, "dev:tty") != 0) {
@@ -131,11 +152,26 @@ long libos_syscall_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg) {
             ret = 0;
             break;
         }
+        case SIOCGIFCONF:
+        case SIOCGIFHWADDR:
+            if (hdl->type == TYPE_SOCK) {
+                /* LibOS doesn't know how to handle this IOCTL, forward it to the host */
+                int cmd_ret;
+                ret = PalDeviceIoControl(hdl->pal_handle, cmd, arg, &cmd_ret);
+                if (ret < 0)
+                    ret = pal_to_unix_errno(ret);
+                else {
+                    assert(ret == 0);
+                    ret = cmd_ret;
+                }
+            }
+            break;
         default:
             ret = -ENOSYS;
             break;
     }
 
+out:
     put_handle(hdl);
     if (ret == -EINTR) {
         ret = -ERESTARTSYS;
diff --git a/libos/test/regression/meson.build b/libos/test/regression/meson.build
index 6d949236..6f3f2e80 100644
--- a/libos/test/regression/meson.build
+++ b/libos/test/regression/meson.build
@@ -13,6 +13,12 @@ tests = {
     },
     'devfs': {},
     'device_passthrough': {},
+    'device_ioctl': {
+        'include_directories': include_directories(
+            # for `gramine_test_dev_ioctl.h`
+            '/usr/local/include/',
+        ),
+    },
     'double_fork': {},
     'epoll_epollet': {},
     'epoll_test': {},
diff --git a/libos/test/regression/test_libos.py b/libos/test/regression/test_libos.py
index a453abd8..58903263 100644
--- a/libos/test/regression/test_libos.py
+++ b/libos/test/regression/test_libos.py
@@ -8,6 +8,7 @@ import unittest
 
 from graminelibos.regression import (
     HAS_SGX,
+    IS_VM,
     ON_X86,
     USES_MUSL,
     RegressionTestCase,
@@ -993,6 +994,11 @@ class TC_40_FileSystem(RegressionTestCase):
         stdout, _ = self.run_binary(['device_passthrough'])
         self.assertIn('TEST OK', stdout)
 
+    @unittest.skipUnless(IS_VM, '/dev/gramine_test_dev is available only on some Jenkins machines')
+    def test_003_device_ioctl(self):
+        stdout, _ = self.run_binary(['device_ioctl'])
+        self.assertIn('TEST OK', stdout)
+
     def test_010_path(self):
         stdout, _ = self.run_binary(['proc_path'])
         self.assertIn('proc path test success', stdout)
diff --git a/libos/test/regression/tests.toml b/libos/test/regression/tests.toml
index b20f52ec..772fc411 100644
--- a/libos/test/regression/tests.toml
+++ b/libos/test/regression/tests.toml
@@ -13,6 +13,7 @@ manifests = [
   "debug_log_inline",
   "devfs",
   "device_passthrough",
+  "device_ioctl",
   "double_fork",
   "env_from_file",
   "env_from_host",
diff --git a/libos/test/regression/tests_musl.toml b/libos/test/regression/tests_musl.toml
index 21069f27..864a9b15 100644
--- a/libos/test/regression/tests_musl.toml
+++ b/libos/test/regression/tests_musl.toml
@@ -15,6 +15,7 @@ manifests = [
   "debug_log_inline",
   "devfs",
   "device_passthrough",
+  "device_ioctl",
   "double_fork",
   "env_from_file",
   "env_from_host",
diff --git a/meson.build b/meson.build
old mode 100644
new mode 100755
diff --git a/meson_options.txt b/meson_options.txt
old mode 100644
new mode 100755
diff --git a/pal/include/pal/pal.h b/pal/include/pal/pal.h
index 80421e1d..1960c6ab 100644
--- a/pal/include/pal/pal.h
+++ b/pal/include/pal/pal.h
@@ -863,6 +863,25 @@ int PalSegmentBaseSet(enum pal_segment_reg reg, uintptr_t addr);
  */
 size_t PalMemoryAvailableQuota(void);
 
+/*!
+ * \brief Perform a device-specific operation `cmd`.
+ *
+ * \param         handle   Handle of the device.
+ * \param         cmd      Device-dependent request/control code.
+ * \param[in,out] arg      Arbitrary argument to `cmd`. May be unused or used as a 64-bit integer
+ *                         or used as a pointer to a buffer that contains the data required to
+ *                         perform the operation as well as the data returned by the operation. For
+ *                         some PALs (e.g. Linux-SGX), the manifest must describe the layout of
+ *                         this buffer in order to correctly copy the data to/from the host.
+ * \param[out]    out_ret  Typically zero, but some device-specific operations return a
+ *                         device-specific nonnegative value (in addition to or instead of \p arg).
+ *
+ * \returns 0 on success, negative error value on failure.
+ *
+ * This function corresponds to ioctl() in UNIX systems and DeviceIoControl() in Windows.
+ */
+int PalDeviceIoControl(PAL_HANDLE handle, uint32_t cmd, unsigned long arg, int* out_ret);
+
 /*!
  * \brief Obtain the attestation report (local) with `user_report_data` embedded into it.
  *
diff --git a/pal/include/pal_internal.h b/pal/include/pal_internal.h
index 980a3cd6..04b4e765 100644
--- a/pal/include/pal_internal.h
+++ b/pal/include/pal_internal.h
@@ -162,6 +162,7 @@ void _PalGetAvailableUserAddressRange(void** out_start, void** out_end);
 bool _PalCheckMemoryMappable(const void* addr, size_t size);
 unsigned long _PalMemoryQuota(void);
 unsigned long _PalMemoryAvailableQuota(void);
+int _PalDeviceIoControl(PAL_HANDLE handle, uint32_t cmd, unsigned long arg, int* out_ret);
 // Returns 0 on success, negative PAL code on failure
 int _PalGetCPUInfo(struct pal_cpu_info* info);
 
diff --git a/pal/src/host/linux-sgx/enclave_ocalls.c b/pal/src/host/linux-sgx/enclave_ocalls.c
index e936cf3f..1e0bc2e0 100644
--- a/pal/src/host/linux-sgx/enclave_ocalls.c
+++ b/pal/src/host/linux-sgx/enclave_ocalls.c
@@ -1988,6 +1988,28 @@ int ocall_eventfd(int flags) {
     return retval;
 }
 
+int ocall_ioctl(int fd, unsigned int cmd, unsigned long arg) {
+    int retval;
+
+    void* old_ustack = sgx_prepare_ustack();
+    ms_ocall_ioctl_t* ms = sgx_alloc_on_ustack_aligned(sizeof(*ms), alignof(*ms));
+    if (!ms) {
+        sgx_reset_ustack(old_ustack);
+        return -EPERM;
+    }
+
+    WRITE_ONCE(ms->ms_fd, fd);
+    WRITE_ONCE(ms->ms_cmd, cmd);
+    WRITE_ONCE(ms->ms_arg, arg);
+
+    retval = sgx_exitless_ocall(OCALL_IOCTL, ms);
+    /* in general case, IOCTL may return any error code (the list of possible error codes is not
+     * standardized and is up to the Linux driver/kernel module), so no check of `retval` here */
+
+    sgx_reset_ustack(old_ustack);
+    return retval;
+}
+
 int ocall_get_quote(const sgx_spid_t* spid, bool linkable, const sgx_report_t* report,
                     const sgx_quote_nonce_t* nonce, char** quote, size_t* quote_len) {
     int retval;
diff --git a/pal/src/host/linux-sgx/enclave_ocalls.h b/pal/src/host/linux-sgx/enclave_ocalls.h
index 3ceaa6b0..4a07652f 100644
--- a/pal/src/host/linux-sgx/enclave_ocalls.h
+++ b/pal/src/host/linux-sgx/enclave_ocalls.h
@@ -105,6 +105,8 @@ int ocall_debug_describe_location(uintptr_t addr, char* buf, size_t buf_size);
 
 int ocall_eventfd(int flags);
 
+int ocall_ioctl(int fd, unsigned int cmd, unsigned long arg);
+
 /*!
  * \brief Execute untrusted code in PAL to obtain a quote from the Quoting Enclave.
  *
diff --git a/pal/src/host/linux-sgx/host_ocalls.c b/pal/src/host/linux-sgx/host_ocalls.c
index 8cb6d7fa..d34c89ac 100644
--- a/pal/src/host/linux-sgx/host_ocalls.c
+++ b/pal/src/host/linux-sgx/host_ocalls.c
@@ -730,6 +730,11 @@ static long sgx_ocall_debug_describe_location(void* pms) {
 #endif
 }
 
+static long sgx_ocall_ioctl(void* pms) {
+    ms_ocall_ioctl_t* ms = pms;
+    return DO_SYSCALL(ioctl, ms->ms_fd, ms->ms_cmd, ms->ms_arg);
+}
+
 static long sgx_ocall_get_quote(void* pms) {
     ms_ocall_get_quote_t* ms = (ms_ocall_get_quote_t*)pms;
     return retrieve_quote(ms->ms_is_epid ? &ms->ms_spid : NULL, ms->ms_linkable, &ms->ms_report,
@@ -781,6 +786,7 @@ sgx_ocall_fn_t ocall_table[OCALL_NR] = {
     [OCALL_DEBUG_MAP_REMOVE]         = sgx_ocall_debug_map_remove,
     [OCALL_DEBUG_DESCRIBE_LOCATION]  = sgx_ocall_debug_describe_location,
     [OCALL_EVENTFD]                  = sgx_ocall_eventfd,
+    [OCALL_IOCTL]                    = sgx_ocall_ioctl,
     [OCALL_GET_QUOTE]                = sgx_ocall_get_quote,
 };
 
diff --git a/pal/src/host/linux-sgx/pal_devices.c b/pal/src/host/linux-sgx/pal_devices.c
index 073e7bd3..0bb4687e 100644
--- a/pal/src/host/linux-sgx/pal_devices.c
+++ b/pal/src/host/linux-sgx/pal_devices.c
@@ -18,6 +18,8 @@
 #include "pal_linux.h"
 #include "pal_linux_error.h"
 #include "perm.h"
+#include "toml.h"
+#include "toml_utils.h"
 
 static int dev_open(PAL_HANDLE* handle, const char* type, const char* uri, enum pal_access access,
                     pal_share_flags_t share, enum pal_create_mode create,
@@ -219,3 +221,808 @@ struct handle_ops g_dev_ops = {
     .attrquery      = &dev_attrquery,
     .attrquerybyhdl = &dev_attrquerybyhdl,
 };
+
+/*
+ * Code below describes the TOML syntax of the manifest entries used for deep-copying complex nested
+ * objects out and inside the SGX enclave. This syntax is currently used for IOCTL emulation. This
+ * syntax is generic enough to describe any memory layout for deep copy of IOCTL structs.
+ *
+ * The high-level description can be found in the "manifest syntax" documentation page.
+ *
+ * The following example describes the main implementation details:
+ *
+ *   struct pascal_str { uint8_t len; char str[]; };
+ *   struct c_str { char str[]; };
+ *   struct root { struct pascal_str* s1; struct c_str* s2; uint64_t s2_len; int8_t x; int8_t y; };
+ *
+ *   alignas(128) struct root obj;
+ *   ioctl(devfd, DEV_IOCTL_NUMBER, &obj);
+ *
+ * The example IOCTL takes as a third argument a pointer to an object of type `struct root` that
+ * contains two pointers to other objects (pascal-style string and a C-style string) and embeds two
+ * integers `x` and `y`. The two strings reside in separate memory regions in enclave memory. Note
+ * that the max possible length of the C-style string is stored in the `s2_len` field of the root
+ * object. The `pascal_str` string is an input to the IOCTL, the `c_str` string and its length
+ * `s2_len` are the outputs of the IOCTL, and the integers `x` and `y` are also outputs of the
+ * IOCTL. Also note that the root object is 128B-aligned (for illustration purposes). This IOCTL
+ * could for example be used to convert a Pascal string into a C string (C string will be truncated
+ * to user-specified `s2_len` if greater than this limit), and find the indices of the first
+ * occurences of chars "x" and "y" in the Pascal string.
+ *
+ * The corresponding manifest entries describing these structs look like this:
+ *
+ *   sgx.ioctl_structs.root = [
+ *     { align = 128, ptr = [
+ *                      { name = "pascal-str-len", size = 1, direction = "out" },
+ *                      { name = "pascal-str", size = "pascal-str-len", direction = "out"}
+ *                    ] },
+ *     { ptr = [
+ *         { name = "c-str", size = "c-str-len", direction = "in" }
+ *       ] },
+ *     { name = "c-str-len", size = 8, direction = "inout" },
+ *     { size = 1, direction = "in" }
+ *     { size = 1, direction = "in" }
+ *   ]
+ *
+ *   sgx.allowed_ioctls = [
+ *     { request_code = <DEV_IOCTL_NUMER>, struct = "root" }
+ *   ]
+ *
+ * One can observe the following rules in this TOML syntax:
+ *
+ *  1. Each separate memory region is represented as a TOML array (`[]`).
+ *  2. Each sub-region of one memory region is represented as a TOML table (`{}`).
+ *  3. Each sub-region may be a pointer (`ptr`) to another memory region. In this case, the value of
+ *     `ptr` is a TOML-array representation of that other memory region or a TOML string with the
+ *     name of another memory region. The `ptr` sub-region always has size of 8B (assuming x86-64)
+ *     and doesn't have an in/out direction.  The `array_len` field specifies the number of adjacent
+ *     memory regions that this pointer points to (i.e. the length of an array).
+ *  4. Sub-regions can be fixed-size (like the last sub-region containing two bytes `x` and `y`) or
+ *     can be flexible-size (like the two strings). In the latter case, the `size` field contains a
+ *     name of a sub-region where the actual size is stored. Note that this referenced sub-region
+ *     must come *before* the sub-region with such flexible-size `size` -- TOML representations of
+ *     typical IOCTL structs always have the size specifier in a sub-region found before the buffer
+ *     sub-region, either in the same memory region (e.g. as in flexible array members in C) or in
+ *     the "outer" memory region (e.g. the size specifier is located in the root memory region and
+ *     the buffer is located in the nested memory region).
+ *  5. Sub-regions that store the size of another sub-region must be less than or equal to 8 bytes
+ *     in size.
+ *  6. Sub-regions may have a name for ease of identification; this is required for "size" /
+ *     "array_len" sub-regions but may be omitted for all other kinds of sub-regions.
+ *  7. Sub-regions may have one of the four directions: "out" to copy contents of the sub-region out
+ *     of the enclave to untrusted memory, "in" to copy from untrusted memory into the enclave,
+ *     "inout" to copy in both directions, "none" to not copy at all (useful for e.g. padding).
+ *     Note that pointer sub-regions do not have a direction (their values are unconditionally
+ *     rewired so as to point to the corresponding region in untrusted memory).
+ *  8. The first sub-region (and only the first!) may specify the alignment of the memory region.
+ *  9. The total size of a sub-region is calculated as `size * unit + adjust`. By default `unit` is
+ *     1 byte and `adjust` is 0. Note that `adjust` may be a negative number.
+ *
+ * The diagram below shows how this complex object is copied from enclave memory (left side) to
+ * untrusted memory (right side). MR stands for "memory region", SR stands for "sub-region". Note
+ * how enclave pointers are copied and rewired to point to untrusted memory regions.
+ *
+ *       struct root (MR1)              |         deep-copied struct (aligned at 128B)
+ *      +------------------+            |       +------------------------+
+ *  +----+ pascal_str* s1  |     SR1    |    +----+ pascal_str* s1  (MR1)|
+ *  |   |                  |            |    |  |                        |
+ *  |   |  c_str* s2 +-------+   SR2    |    |  |   c_str* s2 +-------------+
+ *  |   |                  | |          |    |  |                        |  |
+ *  |   |  uint64_t s2_len | |   SR3    |    |  |   uint64_t s2_len      |  |
+ *  |   |                  | |          |    |  |                        |  |
+ *  |   |  int8_t x, y     | |   SR4    |    |  |   int8_t x, y          |  |
+ *  |   +------------------+ |          |    |  +------------------------+  |
+ *  |                        |          |    +->|   uint8_t len     (MR2)|  |
+ *  v (MR2)                  |          |       |                        |  |
+ * +-------------+           |          |       |   char str[len]        |  |
+ * | uint8_t len |           |   SR5    |       +------------------------+  |
+ * |             |           |          |       |  char str[s2_len] (MR3)|<-+
+ * | char str[]  |           |   SR6    |       +------------------------+
+ * +-------------+           |          |
+ *                  (MR3)    v          |
+ *                +----------+-+        |
+ *                | char str[] | SR7    |
+ *                +------------+        |
+ *
+ */
+
+/* for simplicity, we limit the number of memory and sub-regions; these limits should be enough for
+ * any reasonable IOCTL struct object */
+#define MAX_MEM_REGIONS 1024
+#define MAX_SUB_REGIONS (10 * 1024)
+
+/* direction of copy: none (used for padding), out of enclave, inside enclave, both or a special
+ * "pointer" sub-region; default is DIRECTION_NONE */
+enum mem_copy_direction {
+    DIRECTION_NONE,
+    DIRECTION_OUT,
+    DIRECTION_IN,
+    DIRECTION_INOUT
+};
+
+struct mem_region {
+    toml_array_t* toml_mem_region; /* describes contigious sub_regions in this mem_region */
+    void* enclave_addr;            /* base address of this memory region in enclave memory */
+    bool adjacent;                 /* memory region adjacent to previous one? (used for arrays) */
+};
+
+struct dynamic_value {
+    bool is_determined;
+    union {
+        /* actual value, use only if `is_determined == true` */
+        uint64_t value;
+        /* sub-region name that determines the value, use only if `is_determined == false`;
+         * FIXME: memorize name hash for quicker string comparison? */
+        char* sub_region_name;
+    };
+};
+
+struct sub_region {
+    enum mem_copy_direction direction; /* direction of copy during OCALL */
+    char* name;                     /* may be NULL for unnamed regions */
+    struct dynamic_value array_len; /* array length of the sub-region (only for `ptr` regions) */
+    size_t size;                    /* size of this sub-region */
+    size_t unit;                    /* total size in bytes calculated as `size * unit + adjust` */
+    int64_t adjust;                 /* may be negative; used to adjust total size */
+    size_t align;                   /* alignment of this sub-region */
+    void* enclave_addr;             /* base address of this sub region in enclave mem */
+    void* untrusted_addr;           /* base address of corresponding sub region in untrusted mem */
+    toml_array_t* toml_mem_region;  /* for pointers/arrays, specifies pointed-to mem region */
+};
+
+static bool strings_equal(const char* s1, const char* s2) {
+    if (!s1 || !s2)
+        return false;
+    return !strcmp(s1, s2);
+}
+
+static int copy_value(void* addr, size_t size, uint64_t* out_value) {
+    if (!addr || size > sizeof(*out_value))
+        return -PAL_ERROR_INVAL;
+
+    /* the copy below assumes little-endian machines (which x86 is) */
+    *out_value = 0;
+    memcpy(out_value, addr, size);
+    return 0;
+}
+
+/* finds a sub region with name `sub_region_name` among `all_sub_regions` and returns its index */
+static int get_sub_region_idx(struct sub_region* all_sub_regions, size_t all_sub_regions_cnt,
+                              const char* sub_region_name, size_t* out_idx) {
+    /* it is important to iterate in reverse order because there may be an array of mem regions
+     * with same-named sub regions, and we want to find the latest sub region */
+    for (size_t i = all_sub_regions_cnt; i > 0; i--) {
+        size_t idx = i - 1;
+        if (strings_equal(all_sub_regions[idx].name, sub_region_name)) {
+            *out_idx = idx;
+            return 0;
+        }
+    }
+    return -PAL_ERROR_NOTDEFINED;
+}
+
+/* allocates a name string, it is responsibility of the caller to free it after use */
+static int get_sub_region_name(const toml_table_t* toml_sub_region, char** out_name) {
+    return toml_string_in(toml_sub_region, "name", out_name) < 0 ? -PAL_ERROR_INVAL : 0;
+}
+
+static int get_sub_region_direction(const toml_table_t* toml_sub_region,
+                                    enum mem_copy_direction* out_direction) {
+    char* direction_str;
+    int ret = toml_string_in(toml_sub_region, "direction", &direction_str);
+    if (ret < 0)
+        return -PAL_ERROR_INVAL;
+
+    if (!direction_str) {
+        *out_direction = DIRECTION_NONE;
+        return 0;
+    }
+
+    ret = 0;
+    if (!strcmp(direction_str, "out")) {
+        *out_direction = DIRECTION_OUT;
+    } else if (!strcmp(direction_str, "in")) {
+        *out_direction = DIRECTION_IN;
+    } else if (!strcmp(direction_str, "inout")) {
+        *out_direction = DIRECTION_INOUT;
+    } else if (!strcmp(direction_str, "none")) {
+        *out_direction = DIRECTION_NONE;
+    } else {
+        ret = -PAL_ERROR_INVAL;
+    }
+    free(direction_str);
+    return ret;
+}
+
+static int get_sub_region_align(const toml_table_t* toml_sub_region, size_t* out_align) {
+    int64_t align;
+    int ret = toml_int_in(toml_sub_region, "align", /*defaultval=*/0, &align);
+    if (ret < 0 || align < 0)
+        return -PAL_ERROR_INVAL;
+
+    *out_align = (size_t)align;
+    return 0;
+}
+
+static int get_sub_region_unit(const toml_table_t* toml_sub_region, size_t* out_unit) {
+    int64_t unit;
+    int ret = toml_int_in(toml_sub_region, "unit", /*defaultval=*/1, &unit);
+    if (ret < 0 || unit <= 0)
+        return -PAL_ERROR_INVAL;
+
+    *out_unit = (size_t)unit;
+    return 0;
+}
+
+static int get_sub_region_adjust(const toml_table_t* toml_sub_region, int64_t* out_adjust) {
+    int ret = toml_int_in(toml_sub_region, "adjust", /*defaultval=*/0, out_adjust);
+    return ret < 0 ? -PAL_ERROR_INVAL : 0;
+}
+
+static int get_toml_mem_region(toml_table_t* toml_sub_region, toml_array_t** out_toml_mem_region) {
+    toml_array_t* toml_mem_region = toml_array_in(toml_sub_region, "ptr");
+    if (toml_mem_region) {
+        *out_toml_mem_region = toml_mem_region;
+        return 0;
+    }
+
+    char* ioctl_struct_str;
+    int ret = toml_string_in(toml_sub_region, "ptr", &ioctl_struct_str);
+    if (ret < 0)
+        return -PAL_ERROR_INVAL;
+
+    if (!ioctl_struct_str) {
+        *out_toml_mem_region = NULL;
+        return 0;
+    }
+
+    /* since we're in this function, we are parsing sgx.ioctl_structs list, so we know it exists */
+    toml_table_t* manifest_sgx = toml_table_in(g_pal_public_state.manifest_root, "sgx");
+    assert(manifest_sgx);
+    toml_table_t* toml_ioctl_structs = toml_table_in(manifest_sgx, "ioctl_structs");
+    assert(toml_ioctl_structs);
+
+    toml_mem_region = toml_array_in(toml_ioctl_structs, ioctl_struct_str);
+    if (!toml_mem_region || toml_array_nelem(toml_mem_region) <= 0) {
+        ret = -PAL_ERROR_NOTDEFINED;
+        goto out;
+    }
+
+    *out_toml_mem_region = toml_mem_region;
+    ret = 0;
+out:
+    free(ioctl_struct_str);
+    return ret;
+}
+
+static int get_sub_region_size(struct sub_region* all_sub_regions, size_t all_sub_regions_cnt,
+                               const toml_table_t* toml_sub_region, size_t* out_size) {
+    toml_raw_t sub_region_size_raw = toml_raw_in(toml_sub_region, "size");
+    if (!sub_region_size_raw) {
+        *out_size = 0;
+        return 0;
+    }
+
+    int64_t size;
+    int ret = toml_rtoi(sub_region_size_raw, &size);
+    if (ret == 0) {
+        /* size is specified as constant */
+        if (size <= 0)
+            return -PAL_ERROR_INVAL;
+
+        *out_size = (size_t)size;
+        return 0;
+    }
+
+    /* size must be specified as string (another sub-region's name) */
+    char* sub_region_name = NULL;
+    ret = toml_rtos(sub_region_size_raw, &sub_region_name);
+    if (ret < 0)
+        return -PAL_ERROR_INVAL;
+
+    size_t found_idx;
+    ret = get_sub_region_idx(all_sub_regions, all_sub_regions_cnt, sub_region_name, &found_idx);
+    free(sub_region_name);
+    if (ret < 0)
+        return ret;
+
+    void* addr_of_size_field  = all_sub_regions[found_idx].enclave_addr;
+    size_t size_of_size_field = all_sub_regions[found_idx].size;
+    return copy_value(addr_of_size_field, size_of_size_field, out_size);
+}
+
+/* may allocate an array-len-name string, it is responsibility of the caller to free it after use */
+static int get_sub_region_array_len(const toml_table_t* toml_sub_region,
+                                    struct dynamic_value* out_array_len) {
+    toml_raw_t sub_region_array_len_raw = toml_raw_in(toml_sub_region, "array_len");
+    if (!sub_region_array_len_raw) {
+        *out_array_len = (struct dynamic_value){
+            .is_determined = true,
+            .value = 1  /* 1 array item by default */
+        };
+        return 0;
+    }
+
+    int64_t array_len;
+    int ret = toml_rtoi(sub_region_array_len_raw, &array_len);
+    if (ret == 0) {
+        /* array_len is specified as constant */
+        if (array_len <= 0)
+            return -PAL_ERROR_INVAL;
+
+        *out_array_len = (struct dynamic_value){
+            .is_determined = true,
+            .value = (uint64_t)array_len
+        };
+        return 0;
+    }
+
+    /* array_len must be specified as string (another sub-region's name) */
+    char* sub_region_name = NULL;
+    ret = toml_rtos(sub_region_array_len_raw, &sub_region_name);
+    if (ret < 0)
+        return -PAL_ERROR_INVAL;
+
+    *out_array_len = (struct dynamic_value){
+        .is_determined = false,
+        .sub_region_name = sub_region_name
+    };
+    return 0;
+}
+
+/* Caller sets `mem_regions_cnt_ptr` to the length of `mem_regions` array; this variable is updated
+ * to return the number of actually used `mem_regions`. Similarly with `sub_regions`. */
+static int collect_sub_regions(toml_array_t* root_toml_mem_region, void* root_enclave_addr,
+                               struct mem_region* mem_regions, size_t* mem_regions_cnt_ptr,
+                               struct sub_region* sub_regions, size_t* sub_regions_cnt_ptr) {
+    int ret;
+
+    assert(root_toml_mem_region && toml_array_nelem(root_toml_mem_region) > 0);
+
+    size_t max_sub_regions = *sub_regions_cnt_ptr;
+    size_t sub_regions_cnt = 0;
+
+    size_t max_mem_regions = *mem_regions_cnt_ptr;
+    size_t mem_regions_cnt = 0;
+
+    mem_regions[0].toml_mem_region = root_toml_mem_region;
+    mem_regions[0].enclave_addr    = root_enclave_addr;
+    mem_regions[0].adjacent        = false;
+    mem_regions_cnt++;
+
+    /* collecting memory regions and their sub-regions must use top-to-bottom breadth-first search
+     * to dynamically calculate sizes of sub-regions even if they are specified via another
+     * sub-region's "name" */
+    char* cur_enclave_addr = NULL;
+    size_t mem_region_idx = 0;
+    while (mem_region_idx < mem_regions_cnt) {
+        struct mem_region* cur_mem_region = &mem_regions[mem_region_idx];
+        mem_region_idx++;
+
+        if (!cur_mem_region->adjacent)
+            cur_enclave_addr = cur_mem_region->enclave_addr;
+
+        size_t cur_mem_region_first_sub_region_idx = sub_regions_cnt;
+
+        assert(toml_array_nelem(cur_mem_region->toml_mem_region) >= 0);
+        for (size_t i = 0; i < (size_t)toml_array_nelem(cur_mem_region->toml_mem_region); i++) {
+            toml_table_t* toml_sub_region = toml_table_at(cur_mem_region->toml_mem_region, i);
+            if (!toml_sub_region) {
+                log_error("IOCTL: each memory sub-region must be a TOML table");
+                ret = -PAL_ERROR_INVAL;
+                goto out;
+            }
+
+            if (sub_regions_cnt == max_sub_regions) {
+                log_error("IOCTL: too many memory sub-regions (max is %zu)", max_sub_regions);
+                ret = -PAL_ERROR_NOMEM;
+                goto out;
+            }
+
+            struct sub_region* cur_sub_region = &sub_regions[sub_regions_cnt];
+            sub_regions_cnt++;
+
+            memset(cur_sub_region, 0, sizeof(*cur_sub_region));
+
+            cur_sub_region->enclave_addr = cur_enclave_addr;
+            if (!cur_enclave_addr) {
+                /* FIXME: use `is_user_memory_readable()` to check invalid enclave addresses */
+                ret = -PAL_ERROR_INVAL;
+                goto out;
+            }
+
+            if (toml_raw_in(toml_sub_region, "align") && i != 0) {
+                log_error("IOCTL: 'align' may be specified only at beginning of mem region");
+                ret = -PAL_ERROR_INVAL;
+                goto out;
+            }
+
+            if (toml_array_in(toml_sub_region, "ptr") || toml_raw_in(toml_sub_region, "ptr")) {
+                if (toml_raw_in(toml_sub_region, "direction")) {
+                    log_error("IOCTL: 'ptr' cannot specify 'direction'");
+                    ret = -PAL_ERROR_INVAL;
+                    goto out;
+                }
+                if (toml_raw_in(toml_sub_region, "size")) {
+                    log_error("IOCTL: 'ptr' cannot specify 'size' (did you mean 'array_len'?)");
+                    ret = -PAL_ERROR_INVAL;
+                    goto out;
+                }
+            }
+
+            ret = get_sub_region_name(toml_sub_region, &cur_sub_region->name);
+            if (ret < 0) {
+                log_error("IOCTL: parsing of 'name' field failed");
+                goto out;
+            }
+
+            ret = get_sub_region_direction(toml_sub_region, &cur_sub_region->direction);
+            if (ret < 0) {
+                log_error("IOCTL: parsing of 'direction' field failed");
+                goto out;
+            }
+
+            ret = get_sub_region_align(toml_sub_region, &cur_sub_region->align);
+            if (ret < 0) {
+                log_error("IOCTL: parsing of 'align' field failed");
+                goto out;
+            }
+
+            ret = get_sub_region_unit(toml_sub_region, &cur_sub_region->unit);
+            if (ret < 0) {
+                log_error("IOCTL: parsing of 'unit' field failed");
+                goto out;
+            }
+
+            ret = get_sub_region_adjust(toml_sub_region, &cur_sub_region->adjust);
+            if (ret < 0) {
+                log_error("IOCTL: parsing of 'adjust' field failed");
+                goto out;
+            }
+
+            ret = get_sub_region_size(sub_regions, sub_regions_cnt, toml_sub_region,
+                                      &cur_sub_region->size);
+            if (ret < 0) {
+                log_error("IOCTL: parsing of 'size' field failed");
+                goto out;
+            }
+
+            ret = get_sub_region_array_len(toml_sub_region, &cur_sub_region->array_len);
+            if (ret < 0) {
+                log_error("IOCTL: parsing of 'array_len' field failed");
+                goto out;
+            }
+
+            ret = get_toml_mem_region(toml_sub_region, &cur_sub_region->toml_mem_region);
+            if (ret < 0) {
+                log_error("IOCTL: parsing of 'ptr' field failed");
+                goto out;
+            }
+
+            if (cur_sub_region->toml_mem_region) {
+                /* only set size for now, we postpone pointer/array handling for later */
+                cur_sub_region->size = sizeof(void*);
+            } else {
+                if (__builtin_mul_overflow(cur_sub_region->size, cur_sub_region->unit,
+                                           &cur_sub_region->size)) {
+                    log_error("IOCTL: integer overflow while applying 'unit'");
+                    ret = -PAL_ERROR_OVERFLOW;
+                    goto out;
+                }
+                if (__builtin_add_overflow(cur_sub_region->size, cur_sub_region->adjust,
+                                           &cur_sub_region->size)) {
+                    log_error("IOCTL: integer overflow while applying 'adjust'");
+                    ret = -PAL_ERROR_OVERFLOW;
+                    goto out;
+                }
+            }
+
+            if (!access_ok(cur_enclave_addr, cur_sub_region->size)) {
+                log_error("IOCTL: enclave address overflows");
+                ret = -PAL_ERROR_OVERFLOW;
+                goto out;
+            }
+            cur_enclave_addr += cur_sub_region->size;
+        }
+
+        /* iterate through collected pointer/array sub regions and add corresponding mem regions */
+        for (size_t i = cur_mem_region_first_sub_region_idx; i < sub_regions_cnt; i++) {
+            if (!sub_regions[i].toml_mem_region)
+                continue;
+
+            if (!sub_regions[i].array_len.is_determined) {
+                /* array len was not hard-coded in struct definition, dynamically determine it */
+                assert(sub_regions[i].array_len.sub_region_name);
+
+                size_t found_idx;
+                ret = get_sub_region_idx(sub_regions, sub_regions_cnt,
+                                         sub_regions[i].array_len.sub_region_name, &found_idx);
+                if (ret < 0) {
+                    log_error("IOCTL: cannot find '%s'", sub_regions[i].array_len.sub_region_name);
+                    goto out;
+                }
+
+                void* addr_of_array_len_field  = sub_regions[found_idx].enclave_addr;
+                size_t size_of_array_len_field = sub_regions[found_idx].size;
+                uint64_t array_len;
+                ret = copy_value(addr_of_array_len_field, size_of_array_len_field, &array_len);
+                if (ret < 0) {
+                    log_error("IOCTL: cannot get array len from '%s'",
+                              sub_regions[i].array_len.sub_region_name);
+                    goto out;
+                }
+
+                free(sub_regions[i].array_len.sub_region_name);
+                sub_regions[i].array_len = (struct dynamic_value){
+                    .is_determined = true,
+                    .value = array_len
+                };
+            }
+
+            for (size_t k = 0; k < sub_regions[i].array_len.value; k++) {
+                if (mem_regions_cnt == max_mem_regions) {
+                    log_error("IOCTL: too many memory regions (max is %zu)", max_mem_regions);
+                    ret = -PAL_ERROR_NOMEM;
+                    goto out;
+                }
+
+                void* mem_region_addr = *((void**)sub_regions[i].enclave_addr);
+                if (!mem_region_addr)
+                    continue;
+
+                mem_regions[mem_regions_cnt].toml_mem_region = sub_regions[i].toml_mem_region;
+                mem_regions[mem_regions_cnt].enclave_addr    = mem_region_addr;
+                mem_regions[mem_regions_cnt].adjacent        = k > 0;
+                mem_regions_cnt++;
+            }
+        }
+    }
+
+    *mem_regions_cnt_ptr = mem_regions_cnt;
+    *sub_regions_cnt_ptr = sub_regions_cnt;
+    ret = 0;
+out:
+    for (size_t i = 0; i < sub_regions_cnt; i++) {
+        /* "name" fields are not needed after we collected all sub_regions */
+        free(sub_regions[i].name);
+        if (!sub_regions[i].array_len.is_determined)
+            free(sub_regions[i].array_len.sub_region_name);
+    }
+    return ret;
+}
+
+static int copy_sub_regions_to_untrusted(struct sub_region* sub_regions, size_t sub_regions_cnt,
+                                         void* untrusted_addr) {
+    char* cur_untrusted_addr = untrusted_addr;
+    for (size_t i = 0; i < sub_regions_cnt; i++) {
+        if (!sub_regions[i].size)
+            continue;
+
+        if (sub_regions[i].align > 0) {
+            char* aligned_untrusted_addr = ALIGN_UP_PTR(cur_untrusted_addr, sub_regions[i].align);
+            memset(cur_untrusted_addr, 0, aligned_untrusted_addr - cur_untrusted_addr);
+            cur_untrusted_addr = aligned_untrusted_addr;
+        }
+
+        if (!sgx_is_completely_within_enclave(sub_regions[i].enclave_addr, sub_regions[i].size)
+                || !sgx_is_valid_untrusted_ptr(cur_untrusted_addr, sub_regions[i].size, 1)) {
+            return -PAL_ERROR_DENIED;
+        }
+
+        if (sub_regions[i].direction == DIRECTION_OUT
+                || sub_regions[i].direction == DIRECTION_INOUT) {
+            /* FIXME: use sgx_copy_from_enclave() after rebase */
+            memcpy(cur_untrusted_addr, sub_regions[i].enclave_addr, sub_regions[i].size);
+        } else {
+            memset(cur_untrusted_addr, 0, sub_regions[i].size);
+        }
+
+        sub_regions[i].untrusted_addr = cur_untrusted_addr;
+        cur_untrusted_addr += sub_regions[i].size;
+    }
+
+    for (size_t i = 0; i < sub_regions_cnt; i++) {
+        if (!sub_regions[i].size)
+            continue;
+
+        if (sub_regions[i].toml_mem_region) {
+            void* enclave_ptr_value = *((void**)sub_regions[i].enclave_addr);
+            /* rewire pointer value in untrusted memory to a corresponding untrusted sub-region */
+            for (size_t j = 0; j < sub_regions_cnt; j++) {
+                if (sub_regions[j].enclave_addr == enclave_ptr_value) {
+                    /* FIXME: use sgx_copy_from_enclave() after rebase */
+                    memcpy(sub_regions[i].untrusted_addr, &sub_regions[j].untrusted_addr,
+                           sizeof(void*));
+                    break;
+                }
+            }
+        }
+    }
+
+    return 0;
+}
+
+static int copy_sub_regions_to_enclave(struct sub_region* sub_regions, size_t sub_regions_cnt) {
+    for (size_t i = 0; i < sub_regions_cnt; i++) {
+        if (!sub_regions[i].size)
+            continue;
+
+        if (sub_regions[i].direction == DIRECTION_IN
+                || sub_regions[i].direction == DIRECTION_INOUT) {
+            bool ret = sgx_copy_to_enclave(sub_regions[i].enclave_addr, sub_regions[i].size,
+                                           sub_regions[i].untrusted_addr, sub_regions[i].size);
+            if (!ret)
+                return -PAL_ERROR_DENIED;
+        }
+    }
+    return 0;
+}
+
+/* may return `*out_toml_ioctl_struct = NULL` which means "no struct needed for this IOCTL" */
+static int get_ioctl_struct(toml_table_t* manifest_sgx, toml_table_t* toml_ioctl_table,
+                            toml_array_t** out_toml_ioctl_struct) {
+    toml_raw_t toml_ioctl_struct_raw = toml_raw_in(toml_ioctl_table, "struct");
+    if (!toml_ioctl_struct_raw) {
+        /* no corresponding struct -> base-type or ignored IOCTL argument */
+        *out_toml_ioctl_struct = NULL;
+        return 0;
+    }
+
+    char* ioctl_struct_str = NULL;
+    int ret = toml_rtos(toml_ioctl_struct_raw, &ioctl_struct_str);
+    if (ret < 0) {
+        ret = -PAL_ERROR_INVAL;
+        goto out;
+    }
+
+    if (strcmp(ioctl_struct_str, "") == 0) {
+        /* empty string instead of struct name -> base-type or ignored IOCTL argument */
+        *out_toml_ioctl_struct = NULL;
+        ret = 0;
+        goto out;
+    }
+
+    toml_table_t* toml_ioctl_structs = toml_table_in(manifest_sgx, "ioctl_structs");
+    if (!toml_ioctl_structs) {
+        log_error("There are no IOCTL structs found in manifest");
+        ret = -PAL_ERROR_INVAL;
+        goto out;
+    }
+
+    toml_array_t* toml_ioctl_struct = toml_array_in(toml_ioctl_structs, ioctl_struct_str);
+    if (!toml_ioctl_struct || toml_array_nelem(toml_ioctl_struct) <= 0) {
+        ret = -PAL_ERROR_INVAL;
+        goto out;
+    }
+
+    *out_toml_ioctl_struct = toml_ioctl_struct;
+    ret = 0;
+out:
+    free(ioctl_struct_str);
+    return ret;
+}
+
+/* may return `*out_toml_ioctl_struct = NULL` which means "no struct needed for this IOCTL" */
+static int get_allowed_ioctl_struct(uint32_t cmd, toml_array_t** out_toml_ioctl_struct) {
+    int ret;
+
+    /* find this IOCTL request in the manifest */
+    toml_table_t* manifest_sgx = toml_table_in(g_pal_public_state.manifest_root, "sgx");
+    if (!manifest_sgx)
+        return -PAL_ERROR_NOTIMPLEMENTED;
+
+    toml_array_t* toml_allowed_ioctls = toml_array_in(manifest_sgx, "allowed_ioctls");
+    if (!toml_allowed_ioctls)
+        return -PAL_ERROR_NOTIMPLEMENTED;
+
+    ssize_t toml_allowed_ioctls_cnt = toml_array_nelem(toml_allowed_ioctls);
+    if (toml_allowed_ioctls_cnt <= 0)
+        return -PAL_ERROR_NOTIMPLEMENTED;
+
+    for (size_t idx = 0; idx < (size_t)toml_allowed_ioctls_cnt; idx++) {
+        toml_table_t* toml_ioctl_table = toml_table_at(toml_allowed_ioctls, idx);
+        if (!toml_ioctl_table) {
+            log_error("Invalid allowed IOCTL #%zu in manifest (not a TOML table)", idx + 1);
+            return -PAL_ERROR_INVAL;
+        }
+
+        int64_t request_code;
+        ret = toml_int_in(toml_ioctl_table, "request_code", /*default_val=*/-1, &request_code);
+        if (ret < 0 || request_code < 0) {
+            log_error("Invalid request code of allowed IOCTL #%zu in manifest", idx + 1);
+            return -PAL_ERROR_INVAL;
+        }
+
+        if (request_code == (int64_t)cmd) {
+            /* found this IOCTL request in the manifest, now must find the corresponding struct */
+            ret = get_ioctl_struct(manifest_sgx, toml_ioctl_table, out_toml_ioctl_struct);
+            if (ret < 0) {
+                log_error("Invalid struct value of allowed IOCTL #%zu in manifest", idx + 1);
+            }
+            return ret;
+        }
+    }
+
+    return -PAL_ERROR_NOTIMPLEMENTED;
+}
+
+int _PalDeviceIoControl(PAL_HANDLE handle, uint32_t cmd, unsigned long arg, int* out_ret) {
+    int ret;
+
+    if (handle->hdr.type != PAL_TYPE_DEV)
+        return -PAL_ERROR_INVAL;
+
+    if (handle->dev.fd == PAL_IDX_POISON)
+        return -PAL_ERROR_DENIED;
+
+    toml_array_t* toml_ioctl_struct = NULL;
+    ret = get_allowed_ioctl_struct(cmd, &toml_ioctl_struct);
+    if (ret < 0)
+        return ret;
+
+    if (!toml_ioctl_struct) {
+        /* special case of "no struct needed for IOCTL" -> base-type or ignored IOCTL argument */
+        ret = ocall_ioctl(handle->dev.fd, cmd, arg);
+        if (ret < 0)
+            return unix_to_pal_error(ret);
+
+        *out_ret = ret;
+        return 0;
+    }
+
+    void* untrusted_addr = NULL;
+
+    size_t mem_regions_cnt = MAX_MEM_REGIONS;
+    size_t sub_regions_cnt = MAX_SUB_REGIONS;
+    struct mem_region* mem_regions = calloc(mem_regions_cnt, sizeof(*mem_regions));
+    struct sub_region* sub_regions = calloc(sub_regions_cnt, sizeof(*sub_regions));
+    if (!mem_regions || !sub_regions) {
+        ret = -PAL_ERROR_NOMEM;
+        goto out;
+    }
+
+    /* deep-copy the IOCTL argument's input data outside of enclave, execute the IOCTL OCALL, and
+     * deep-copy the IOCTL argument's output data back into enclave */
+    ret = collect_sub_regions(toml_ioctl_struct, (void*)arg, mem_regions, &mem_regions_cnt,
+                              sub_regions, &sub_regions_cnt);
+    if (ret < 0) {
+        log_error("IOCTL: failed to parse ioctl struct (request code = 0x%x)", cmd);
+        goto out;
+    }
+
+    size_t untrusted_size = 0;
+    for (size_t i = 0; i < sub_regions_cnt; i++)
+        untrusted_size += sub_regions[i].size + sub_regions[i].align;
+
+    ret = ocall_mmap_untrusted(&untrusted_addr, ALLOC_ALIGN_UP(untrusted_size),
+                               PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, /*fd=*/-1,
+                               /*offset=*/0);
+    if (ret < 0) {
+        ret = unix_to_pal_error(ret);
+        goto out;
+    }
+
+    assert(untrusted_addr);
+    ret = copy_sub_regions_to_untrusted(sub_regions, sub_regions_cnt, untrusted_addr);
+    if (ret < 0)
+        goto out;
+
+    int ioctl_ret = ocall_ioctl(handle->dev.fd, cmd, (unsigned long)untrusted_addr);
+    if (ioctl_ret < 0) {
+        ret = unix_to_pal_error(ioctl_ret);
+        goto out;
+    }
+
+    ret = copy_sub_regions_to_enclave(sub_regions, sub_regions_cnt);
+    if (ret < 0)
+        goto out;
+
+    *out_ret = ioctl_ret;
+    ret = 0;
+out:
+    if (untrusted_addr)
+        ocall_munmap_untrusted(untrusted_addr, ALLOC_ALIGN_UP(untrusted_size));
+    free(mem_regions);
+    free(sub_regions);
+    return ret;
+}
diff --git a/pal/src/host/linux-sgx/pal_ocall_types.h b/pal/src/host/linux-sgx/pal_ocall_types.h
index 6acb0cca..f6fbc17a 100644
--- a/pal/src/host/linux-sgx/pal_ocall_types.h
+++ b/pal/src/host/linux-sgx/pal_ocall_types.h
@@ -68,6 +68,7 @@ enum {
     OCALL_DEBUG_MAP_REMOVE,
     OCALL_DEBUG_DESCRIBE_LOCATION,
     OCALL_EVENTFD,
+    OCALL_IOCTL,
     OCALL_GET_QUOTE,
     OCALL_NR,
 };
@@ -322,6 +323,12 @@ typedef struct {
     int          ms_flags;
 } ms_ocall_eventfd_t;
 
+typedef struct {
+    int           ms_fd;
+    unsigned int  ms_cmd;
+    unsigned long ms_arg;
+} ms_ocall_ioctl_t;
+
 typedef struct {
     bool              ms_is_epid;
     sgx_spid_t        ms_spid;
diff --git a/pal/src/host/linux/pal_devices.c b/pal/src/host/linux/pal_devices.c
index e3bd3320..c1fbccbd 100644
--- a/pal/src/host/linux/pal_devices.c
+++ b/pal/src/host/linux/pal_devices.c
@@ -209,3 +209,18 @@ struct handle_ops g_dev_ops = {
     .attrquery      = &dev_attrquery,
     .attrquerybyhdl = &dev_attrquerybyhdl,
 };
+
+int _PalDeviceIoControl(PAL_HANDLE handle, uint32_t cmd, unsigned long arg, int* out_ret) {
+    if (handle->hdr.type != PAL_TYPE_DEV)
+        return -PAL_ERROR_INVAL;
+
+    if (handle->dev.fd == PAL_IDX_POISON)
+        return -PAL_ERROR_DENIED;
+
+    int ret = DO_SYSCALL(ioctl, handle->dev.fd, cmd, arg);
+    if (ret < 0)
+        return unix_to_pal_error(ret);
+
+    *out_ret = ret;
+    return 0;
+}
diff --git a/pal/src/host/skeleton/pal_devices.c b/pal/src/host/skeleton/pal_devices.c
index 418b7c22..c5249b8c 100644
--- a/pal/src/host/skeleton/pal_devices.c
+++ b/pal/src/host/skeleton/pal_devices.c
@@ -55,3 +55,7 @@ struct handle_ops g_dev_ops = {
     .attrquery      = &dev_attrquery,
     .attrquerybyhdl = &dev_attrquerybyhdl,
 };
+
+int _PalDeviceIoControl(PAL_HANDLE handle, uint32_t cmd, unsigned long arg, int* out_ret) {
+    return -PAL_ERROR_NOTIMPLEMENTED;
+}
diff --git a/pal/src/pal_misc.c b/pal/src/pal_misc.c
index b78e813f..37fe2cdf 100644
--- a/pal/src/pal_misc.c
+++ b/pal/src/pal_misc.c
@@ -30,6 +30,10 @@ size_t PalMemoryAvailableQuota(void) {
     return _PalMemoryAvailableQuota();
 }
 
+int PalDeviceIoControl(PAL_HANDLE handle, uint32_t cmd, unsigned long arg, int* out_ret) {
+    return _PalDeviceIoControl(handle, cmd, arg, out_ret);
+}
+
 #if defined(__x86_64__)
 int PalCpuIdRetrieve(uint32_t leaf, uint32_t subleaf, uint32_t values[4]) {
     return _PalCpuIdRetrieve(leaf, subleaf, values);
diff --git a/pal/src/pal_symbols b/pal/src/pal_symbols
index 487b2d29..2f1d0f4a 100644
--- a/pal/src/pal_symbols
+++ b/pal/src/pal_symbols
@@ -44,6 +44,7 @@ PalSegmentBaseSet
 PalStreamChangeName
 PalStreamAttributesSetByHandle
 PalMemoryAvailableQuota
+PalDeviceIoControl
 PalDebugMapAdd
 PalDebugMapRemove
 PalDebugDescribeLocation
diff --git a/pytest.ini b/pytest.ini
old mode 100644
new mode 100755
diff --git a/python/graminelibos/regression.py b/python/graminelibos/regression.py
index 9bdbc955..65c99868 100644
--- a/python/graminelibos/regression.py
+++ b/python/graminelibos/regression.py
@@ -17,6 +17,7 @@ fspath = getattr(os, 'fspath', str) # pylint: disable=invalid-name
 # pylint: disable=subprocess-popen-preexec-fn,subprocess-run-check
 
 HAS_SGX = os.environ.get('SGX') == '1'
+IS_VM = os.environ.get('IS_VM') == '1'
 ON_X86 = os.uname().machine in ['x86_64']
 USES_MUSL = os.environ.get('GRAMINE_MUSL') == '1'
 
